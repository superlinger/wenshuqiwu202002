[{
  "tag": "P",
  "text": "About the author:",
  "translation": "关于作者："
}, {
  "tag": "P",
  "text": "Ravi Rajan is a global IT program manager based out of Mumbai, India. He is also an avid blogger, Haiku poetry writer, archaeology enthusiast, and history maniac. Connect with Ravi on LinkedIn, Medium and Twitter.",
  "translation": "Ravi Rajan是位于印度孟买的全球IT计划经理。 他还是一位狂热的博客作者，Hai句诗作家，考古爱好者和历史狂人。 在LinkedIn，Medium和Twitter上与Ravi联系。"
}, {
  "tag": "H1",
  "text": "Final thoughts",
  "translation": "最后的想法"
}, {
  "tag": "P",
  "text": "In general, writing reusable code is not about developing generic, monolithic mega blocks of code. The key to writing reusable code is to write focused, composable components with high cohesion and loose coupling.",
  "translation": "通常，编写可重用的代码与开发通用的，巨型的代码块无关。 编写可重用代码的关键是编写具有高内聚力和松散耦合的，集中的，可组合的组件。"
}, {
  "tag": "P",
  "text": "And lastly, don’t make code reusability a goal. It is simply not worth it. Make avoiding code duplication a goal. Make avoiding writing wasteful code as a goal. Make writing clean, easy-to-understand, easy-to-maintain code as a goal. Reusability will come automatically once you start thinking with the right mindset.",
  "translation": "最后，不要将代码可重用性作为目标。 根本不值得。 使避免代码重复成为目标。 以避免编写浪费的代码为目标。 使编写干净，易于理解，易于维护的代码成为目标。 一旦开始以正确的心态进行思考，可重用性就会自动出现。"
}, {
  "tag": "P",
  "text": "Remember, writing reusable code starts with solving a problem and solving it well. The rest should all fall from there, and you can pick whichever method is more appropriate to go to the next level.",
  "translation": "请记住，编写可重用的代码首先要解决问题，然后才能解决问题。 其余的都应该落在那儿，您可以选择哪种方法更适合进入下一个层次。"
}, {
  "tag": "P",
  "text": "As Ralph Johnson has rightly said.",
  "translation": "正如拉尔夫·约翰逊（Ralph Johnson）正确说的。"
}, {
  "tag": "P",
  "text": "Before software can be reusable, it first has to be usable.",
  "translation": "在软件可以重用之前，首先必须要使用它。"
}, {
  "tag": "H1",
  "text": "Avoid excessive use of inheritance",
  "translation": "避免过多使用继承"
}, {
  "tag": "P",
  "text": "Sometimes as developers, we try to think way ahead into the future of the project, coding some extra features “just in case we need them” or thinking “we will eventually need it”.",
  "translation": "有时，作为开发人员，我们试图考虑到项目的未来，“为防万一需要”编码一些额外的功能，或者“最终将需要”。"
}, {
  "tag": "P",
  "text": "Just don’t do it. You didn’t need it, you don’t need it and in most of the cases… “You Aren’t Gonna Need It” (YAGNI)",
  "translation": "只是不要这样做。 您不需要它，在大多数情况下……“您根本不需要它”（YAGNI）"
}, {
  "tag": "P",
  "text": "The same principle applies to inheritance also. Do not introduce an inheritance layer unless it is clear that you will have multiple implementations.",
  "translation": "同样的原则也适用于继承。 除非很明显您将有多个实现，否则不要引入继承层。"
}, {
  "tag": "P",
  "text": "That said, inheritance is a great way to extend a class’s functionality. But developers tend to mismanage inheritance by taking inheritance levels up to six or more in classes, which is absurd.",
  "translation": "也就是说，继承是扩展类功能的好方法。 但是开发人员倾向于通过在类中将继承级别设置为多达六个或更多来对继承进行错误管理，这是荒谬的。"
}, {
  "tag": "P",
  "text": "As the Gang of Four aptly describes the dangers of over inheritance in their book design patterns.",
  "translation": "正如“四人帮”在其书本设计模式中恰当地描述了过度继承的危险。"
}, {
  "tag": "P",
  "text": "“Because inheritance exposes a subclass to details of its parent’s implementation, it’s often said that ‘inheritance breaks encapsulation’.”",
  "translation": "“因为继承将子类公开给其父级实现的详细信息，所以人们常说'继承破坏封装'。”"
}, {
  "tag": "P",
  "text": "Inheritance causes a high coupling, as the superclass exposes its internals to subclasses and the subclasses, in turn, depend entirely on the superclass for their functionality. This makes it rigid and difficult to change the functionality of the superclass when required. That is why inheritance is not a good way to achieve code reuse.",
  "translation": "继承导致高度耦合，因为超类将其内部公开给子类，而子类的功能又完全依赖于超类。 这使得僵硬并且在需要时难以更改超类的功能。 这就是为什么继承不是实现代码重用的好方法。"
}, {
  "tag": "P",
  "text": "A better approach can be to think in terms of the composition of objects instead of inheritance. That allows users to much more easily pull in the functionality they need and create their own objects based on their own constraints. You can even think about creating procedural interfaces that any class can implement in its own way. Interfaces are often easier to understand and implement than classes that involve multiple levels of inheritance.",
  "translation": "更好的方法是根据对象的组成而不是继承来考虑。 这使用户可以更轻松地获取所需的功能，并根据自己的约束创建自己的对象。 您甚至可以考虑创建任何类都可以以自己的方式实现的过程接口。 与涉及多个继承级别的类相比，接口通常更易于理解和实现。"
}, {
  "tag": "P",
  "text": "In general, inheritance should be used only when one class is an extension of another one and most of the code of the inheriting class is using the code of the superclass. Anything beyond this is suicidal to manage from a reusability perspective.",
  "translation": "通常，仅当一个类是另一类的扩展并且继承类的大多数代码使用超类的代码时，才应使用继承。 从可重用性的角度来看，任何超出此范围的措施都是自杀的。"
}, {
  "tag": "H1",
  "text": "Make a class/method/function do just one thing",
  "translation": "让类/方法/函数做一件事"
}, {
  "tag": "P",
  "text": "Louis Sullivan once beautifully said.",
  "translation": "路易斯·沙利文曾经很漂亮地说过。"
}, {
  "tag": "P",
  "text": "“Form follows function.”",
  "translation": "“形式遵循功能。”"
}, {
  "tag": "P",
  "text": "This means only one thing per class/function gives us only one reason to change it. This often means creating methods that other methods use but this helps to make the methods/classes simple and less coupled.",
  "translation": "这意味着每个类/函数只有一件事给我们更改它的一个理由。 这通常意味着创建其他方法使用的方法，但这有助于使方法/类变得简单且耦合程度降低。"
}, {
  "tag": "P",
  "text": "Every system is built from a domain-specific language that is designed by the programmers to describe it aptly. Functions are the verbs of that language and classes are the nouns. They both are usually the first line of organization in any programming language and writing them well is the essence of writing good code.",
  "translation": "每个系统都是由特定领域的语言构建的，该语言是程序员设计的，以恰当地描述它。 函数是该语言的动词，类是名词。 在任何编程语言中，它们通常都是组织的第一线，编写好代码是编写好代码的本质。"
}, {
  "tag": "P",
  "text": "There are only two golden rules for writing a reusable class/function.",
  "translation": "编写可重用的类/函数只有两个黄金法则。"
}, {
  "tag": "P",
  "text": "· They should be small",
  "translation": "·它们应该很小"
}, {
  "tag": "P",
  "text": "· They should do only one thing and they should do it well",
  "translation": "·他们应该只做一件事，并且应该做好"
}, {
  "tag": "P",
  "text": "So this means that your function should not be large enough to hold nested structures. Therefore, the indent level of a function should not be greater than one or two. This technique makes it easier to read, understand and digest. In addition to this, we also need to make sure that the statements within our function are all at the same level of abstraction.",
  "translation": "因此，这意味着您的函数不应足够大以容纳嵌套结构。 因此，函数的缩进级别不应大于一或两个。 这种技术使阅读，理解和消化变得更加容易。 除此之外，我们还需要确保函数中的语句处于相同的抽象级别。"
}, {
  "tag": "P",
  "text": "Mixing levels of abstraction is always very confusing and leads to unmanageable code in due time. Master programmers think of reusable code as stories to be told rather than code to be written.",
  "translation": "混合的抽象级别总是非常令人困惑，并在适当的时候导致无法管理的代码。 熟练的程序员将可重用代码视为要讲的故事，而不是要编写的代码。"
}, {
  "tag": "P",
  "text": "They use the facilities of their chosen programming language to construct a richer, expressive, and cleaner code blocks which can act as a perfect storyteller.",
  "translation": "他们使用所选编程语言的功能来构建更丰富，更具表现力和更简洁的代码块，从而可以充当理想的讲故事的人。"
}, {
  "tag": "H1",
  "text": "Code reuse should focus on avoiding duplication.",
  "translation": "代码重用应着重于避免重复。"
}, {
  "tag": "P",
  "text": "Lemony Snicket has rightly said.",
  "translation": "Lemony Snicket说得对。"
}, {
  "tag": "P",
  "text": "“Don’t repeat yourself. It’s not only repetitive, it’s redundant, and people have heard it before.”",
  "translation": "“不要重复自己。 它不仅是重复的，而且是多余的，而且人们以前也听说过。”"
}, {
  "tag": "P",
  "text": "Remember we spoke about emergent reuse. The goal of code usability should be only that and nothing else. So write the code you need and keep doing that, right up to the point that you start repetitively solving the same problem. Then refactor that solution out into a common location and refer to it. This way, you are not creating wasteful generic code. You are creating code that is avoiding duplicity.",
  "translation": "记住，我们谈论过紧急重用。 代码可用性的目标应该仅此而已。 因此，编写所需的代码并继续这样做，直到开始重复解决相同的问题为止。 然后将该解决方案重构到一个公共位置并进行引用。 这样，您就不会创建浪费的通用代码。 您正在创建避免重复的代码。"
}, {
  "tag": "P",
  "text": "That said, the DRY (Don’t repeat yourself) principle reiterates the same thing, which states that code logic should not be repeated as duplicate code leads to technical debt. Unnecessarily repeating code clogs the system resulting in poor quality. Also, it creates a code monster, which becomes a nightmare for maintainability.",
  "translation": "也就是说，DRY（不要重复自己）原则重申了同一件事，该原则指出不应重复代码逻辑，因为重复的代码会导致技术负担。 不必要的重复代码会阻塞系统，从而导致质量下降。 此外，它还会创建一个代码怪兽，这成为可维护性的噩梦。"
}, {
  "tag": "P",
  "text": "Remember DRY is more of a philosophy in which team members have to let go of their individual coding egos and work for the greater good of the project. If somebody has already done something, use it. Don’t reinvent the wheel.",
  "translation": "请记住，DRY更像是一种哲学，团队成员必须放下个人的编码自我，并为项目的更大利益而努力。 如果有人已经做过某事，请使用它。 不要重新发明轮子。"
}, {
  "tag": "H1",
  "text": "How to Make Your Code Reusable",
  "translation": "如何使您的代码可重用"
}, {
  "tag": "H2",
  "text": "Reusable code is not generic code.",
  "translation": "可重用代码不是通用代码。"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*pRyGoBswAG3Z1rD04JbKoA.jpeg?q=20",
  "caption": "Image Credits: Pixabay.com",
  "type": "image",
  "file": "1!pRyGoBswAG3Z1rD04JbKoA.jpeg"
}, {
  "tag": "P",
  "text": "Reusable code, as a one-stop solution to fix all software problems, is a dangerous myth. Let me explain why.",
  "translation": "可重用的代码作为解决所有软件问题的一站式解决方案，是一个危险的神话。 让我解释一下原因。"
}, {
  "tag": "P",
  "text": "Let’s say you are writing a software library. You have a great idea bubbling in your head that can create a broadly reusable generic solution. You maniacally code APIs which cover all functionalities and cater to all scenarios. Every possible new scenario, you add it to your API. Your code grows disproportionately. But it is generic in the true sense and everybody starts using it. You are happy.",
  "translation": "假设您正在编写软件库。 您脑中冒出一个好主意，可以创建可广泛使用的通用解决方案。 您可以疯狂地编写涵盖所有功能并适应所有场景的API。 每种可能的新方案，都将其添加到您的API中。 您的代码不成比例地增长。 但是从真正意义上讲它是通用的，每个人都开始使用它。 你很高兴。"
}, {
  "tag": "P",
  "text": "Then one day, a new API comes along. It is leaner and covers more scenarios than your API. It is also faster and easier to use. Your API sinks into oblivion. Everyone quickly moves to the next shiny thing. But again history repeats itself. This API also gets bloated with additional code catering to different use cases and eventually gets replaced by something else and so on…",
  "translation": "然后有一天，新的API出现了。 它比API更精简，涵盖了更多方案。 它也更快，更容易使用。 您的API被淘汰。 每个人都迅速移到下一个闪亮的事物。 但是历史再次重演。 该API还因满足不同用例的附加代码而变得肿，最终被其他东西取代，依此类推……"
}, {
  "tag": "P",
  "text": "What is wrong here?",
  "translation": "怎么了"
}, {
  "tag": "P",
  "text": "The root cause of all problems is writing generic solutions. When any reusable code focuses on only the generic case as much as possible, it gets bloated, unwieldy to use, and eventually becomes a painful affair.",
  "translation": "所有问题的根本原因在于编写通用解决方案。 当任何可重用的代码尽可能只关注通用案例时，它就会变得肿，难以使用，并最终成为一件痛苦的事情。"
}, {
  "tag": "P",
  "text": "Being generic is a basic requirement for reusable software. However, making software too generic causes it’s usability to suffer. Thus, in a nutshell, writing good reusable code is not about writing generic code. It is a lot more than that.",
  "translation": "通用是可重用软件的基本要求。 但是，使软件过于通用会导致其可用性受损。 因此，简而言之，编写好的可重用代码与编写通用代码无关。 不仅如此。"
}, {
  "tag": "P",
  "text": "Writing practical and reusable code should focus on emergent use rather than long-time use. Let us say you come across code that can be reused in your application. You adopt it, improve it a bit, and use it within your application. This way you only pay the price for what you actually need when you need it.",
  "translation": "编写实用且可重用的代码应侧重于紧急使用，而不是长期使用。 假设您遇到了可以在应用程序中重用的代码。 您可以采用它，对其进行一些改进，然后在您的应用程序中使用它。 这样，您仅在需要时才支付实际需要的价格。"
}, {
  "tag": "P",
  "text": "Later you find that the improved code can be further be used in some other application. You take the improved code again, enhance it a bit and reuse it again. Thus by incremental reusability, you are not only taking the optimal benefit of the code but also ensuring that non-usable, not-required code is not part of your solution.",
  "translation": "稍后，您发现改进的代码可以在其他应用程序中进一步使用。 您将再次使用经过改进的代码，对其进行增强，然后再次使用。 因此，通过提高可重用性，您不仅可以充分利用代码的优势，而且还可以确保不使用，不需要的代码不属于您的解决方案。"
}, {
  "tag": "P",
  "text": "The key here is NOT trying to predict the future. The scope for reusability should only remain within your immediate visibility of things, and you enhance the code when new opportunities come into play. This way you are not only saving time and effort, but you also end up creating a leaner, meaner, and more up to date reusable code.",
  "translation": "这里的关键不是试图预测未来。 可重用性的范围应该只在您对事物的直接可见性之内，并且当新的机会发挥作用时，您可以增强代码。 这样，您不仅可以节省时间和精力，而且还可以最终创建出更精简，更有意义的代码以及可重复使用的最新代码。"
}, {
  "tag": "P",
  "text": "And here are some ways to make your code practically reusable.",
  "translation": "这里有一些使代码实际上可重用的方法。"
}, {
  "tag": "PRE",
  "text": "(本文翻译自Ravi Shankar Rajan的文章《How to Make Your Code Reusable》，参考：https://levelup.gitconnected.com/how-to-make-your-code-reusable-891ea5db415c)",
  "translation": "（本文翻译自Ravi Shankar Rajan的文章，《如何使代码可重用》，参考：https：//levelup.gitconnected.com/how-to-make-your-code-reusable-891ea5db415c）"
}]